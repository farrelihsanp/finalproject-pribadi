generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("SUPABASE_DATABASE_URL")
    directUrl = env("SUPABASE_DIRECT_URL")
}

/**
 * ENUM
 */

enum Role {
    CUSTOMERS
    SUPERADMIN
    STOREADMIN
    UNSET
}

enum DiscountType {
    AMOUNT
    PERCENTAGE
    BUY_1_GET_1
}

enum VoucherType {
    PERCENTAGE
    AMOUNT
}

enum OrderStatus {
    PENDING_PAYMENT
    FAILED
    PAID
    PROCESSING
    SHIPPED
    DELIVERED
    COMPLETED
    CANCELLED
}

enum PaymentMethodType {
    UNSET
    MIDTRANS
    BANK_TRANSFER
}

enum Provider {
    GOOGLE
    TWITTER
    GITHUB
    CREDENTIALS
}

// MODEL

model User {
    id Int @id @default(autoincrement())

    name           String
    username       String   @unique
    password       String
    email          String   @unique
    emailConfirmed Boolean  @default(false)
    role           Role
    profileImage   String
    referralNumber String   @unique
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt
    referralCount  Int      @default(0)
    provider       Provider
    isVerified     Boolean  @default(false)
    Cart           Cart?

    // ONE TO MANY
    Referral     Referral[]
    ConfirmToken ConfirmToken[]
    Addresses    Address[]
    orders       Order[]

    // MANY TO MANY
    StoreUser   StoreUser[]
    VoucherUser VoucherUser[]
}

model Cart {
    id Int @id @default(autoincrement())

    userId Int @unique

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    cartItems    CartItem[]
    ShippingCost ShippingCost[]
    user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CartItem {
    id        Int @id @default(autoincrement())
    cartId    Int
    productId Int

    quantity Int
    price    Decimal
    total    Int

    cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
    product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Address {
    id Int @id @default(autoincrement())

    userId Int

    street     String
    city       String
    postalCode Int
    country    String
    number     Int
    isPrimary  Boolean  @default(false)
    isActive   Boolean  @default(false)
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    user  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    Order Order[]
}

model Product {
    id Int @id @default(autoincrement())

    storeId Int

    name        String
    excerpt     String
    description String
    date        DateTime
    price       Decimal
    slug        String
    stock       Int
    isCheap     Boolean  @default(false)
    weight      Float

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)

    // ONE TO MANY
    ordersItems OrderItem[]

    // MANY TO MANY
    CategoryProduct CategoryProduct[]
    CartItem        CartItem[]
    ProductImages   ProductImage[]
    VoucherProduct  VoucherProduct[]
}

model ProductImage {
    id        Int    @id @default(autoincrement())
    productId Int
    imageUrl  String

    product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Category {
    id Int @id @default(autoincrement())

    storeId Int

    name        String
    excerpt     String
    description String
    image       String
    slug        String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // ONE TO MANY  
    Store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

    // MANY TO MANY
    CategoryProduct CategoryProduct[]
}

model Referral {
    id             Int      @id @default(autoincrement())
    referredById   Int
    referredUserId Int
    createdAt      DateTime @default(now())

    referredBy User @relation(fields: [referredById], references: [id], onDelete: Cascade)
}

model ConfirmToken {
    id          Int      @id @default(autoincrement())
    userId      Int
    token       String
    expiredDate DateTime
    used        Boolean  @default(false)
    createdAt   DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Store {
    id Int @id @default(autoincrement())

    name               String
    storeImage         String
    address            String
    city               String
    province           String
    country            String
    postalCode         String
    phoneNumber        String
    slug               String
    latitude           Float
    longitude          Float
    maxServiceDistance Float?

    isActive  Boolean  @default(true)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // ONE TO MANY
    Voucher  Voucher[]
    products Product[]
    orders   Order[]

    // MANY TO MANY
    StoreUser StoreUser[]
    Category  Category[]
}

model Voucher {
    id Int @id @default(autoincrement())

    userId  Int
    storeId Int?

    name              String
    description       String
    code              String      @unique
    voucherType       VoucherType
    value             Int
    startDate         DateTime
    endDate           DateTime
    stock             Int
    isActive          Boolean     @default(true)
    minPurchase       Float?
    maxPriceReduction Float?
    voucherImage      String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    store          Store?           @relation(fields: [storeId], references: [id], onDelete: Cascade)
    VoucherProduct VoucherProduct[]
    VoucherUser    VoucherUser[]
}

model VoucherUser {
    id         Int      @id @default(autoincrement())
    voucherId  Int
    customerId Int
    claimedAt  DateTime @default(now())

    voucher  Voucher @relation(fields: [voucherId], references: [id], onDelete: Cascade)
    customer User    @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model Order {
    id Int @id @default(autoincrement())

    userId            Int
    storeId           Int
    shippingAddressId Int

    slug                   String
    paymentMethodType      PaymentMethodType
    shippingCost           Float
    totalAmount            Float
    status                 OrderStatus       @default(PENDING_PAYMENT)
    paymentProof           String?           @unique
    paymentProofUploadedAt DateTime?
    orderConfirmationAt    DateTime?
    createdAt              DateTime          @default(now())
    updatedAt              DateTime          @updatedAt

    user            User        @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    shippingAddress Address     @relation(fields: [shippingAddressId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    store           Store       @relation(fields: [storeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    orderItems      OrderItem[]
}

model OrderItem {
    id Int @id @default(autoincrement())

    productId Int
    orderId   Int

    quantity Int
    price    Float
    total    Float

    order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    product Product @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model ShippingCost {
    id Int @id @default(autoincrement())

    cartId Int

    courierName   String
    code          String
    serviceType   String
    description   String
    shippingCost  Float
    estimatedTime String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    cart Cart @relation(fields: [cartId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

/**
 * --------------------------------------------------------------------------
 */
/**
 * MANY TO MANY
 */
/**
 * --------------------------------------------------------------------------
 */

model CategoryProduct {
    id         Int @id @default(autoincrement())
    productId  Int
    categoryId Int

    Product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    Category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model StoreUser {
    id        Int      @id @default(autoincrement())
    userId    Int
    storeId   Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user  User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    store Store @relation(fields: [storeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model VoucherProduct {
    id        Int @id @default(autoincrement())
    voucherId Int
    productId Int

    voucher Voucher @relation(fields: [voucherId], references: [id], onDelete: Cascade)
    product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// MODEL MENCOBA
model wallet {
    id        Int      @id @default(autoincrement())
    userId    Int
    storeId   Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model walletTransaction {
    id        Int      @id @default(autoincrement())
    userId    Int
    storeId   Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model walletHistory {
    id        Int      @id @default(autoincrement())
    userId    Int
    storeId   Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model walletHistoryTransaction {
    id        Int      @id @default(autoincrement())
    userId    Int
    storeId   Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}
